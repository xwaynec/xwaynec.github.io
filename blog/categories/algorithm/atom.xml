<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Wayne-WH.Chen Blog]]></title>
  <link href="http://xwaynec.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://xwaynec.github.io/"/>
  <updated>2016-02-16T01:36:40+08:00</updated>
  <id>http://xwaynec.github.io/</id>
  <author>
    <name><![CDATA[xwaynec]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ACM: 302 - John's trip]]></title>
    <link href="http://xwaynec.github.io/blog/2013/11/30/acm-302-johns-trip/"/>
    <updated>2013-11-30T02:59:15+08:00</updated>
    <id>http://xwaynec.github.io/blog/2013/11/30/acm-302-johns-trip</id>
    <content type="html"><![CDATA[<p>``` c</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;stdlib.h></h1>

<p>/<em> John&rsquo;s trip  </em>/
int count,visited,totalnode,stack,startPoint;;
int adj[4000],degree[4000],boundary[4000],edge[4000],used[100];
int S[500000];</p>

<p>struct group
{</p>

<pre><code>int head;
int tail;
int street;
</code></pre>

<p>}group[4000];</p>

<p>struct node
{</p>

<pre><code>int adj;
int bound;  /* bound = adj+degree */
int degree;
int color;
</code></pre>

<p>}vertex[100];</p>

<p>int comp_func( const void * a, const void * b )
{
  struct group c = <em>(struct group </em>) a;
  struct group d = <em>(struct group </em>) b;
  int x = c.head &ndash; d.head;</p>

<p>  if( x == 0 )
  x = c.street &ndash; d.street;</p>

<p>  return x;
}</p>

<p>void DFS(int v)
{
  int i;
  visited++;
  used[v] = 1;
  for(i=adj[v];i&lt;boundary[v];i++){</p>

<pre><code>if(used[group[i].tail]==0)
  DFS(group[i].tail);
}
</code></pre>

<p>}</p>

<p>void find_circuit(int i)
{</p>

<pre><code>int j;
if(degree[i]==0){
    return ;
}
for(j=adj[i];j&lt;boundary[i];j++){
    if(edge[group[j].street]==0){
        edge[group[j].street]=1;
        degree[group[j].head]--;
        degree[group[j].tail]--;
        find_circuit(group[j].tail);
        S[stack++]=group[j].street;
    }
}
</code></pre>

<p>}
void build_adj()
{</p>

<pre><code>int i,j;
int cnt,inode,step2;
int count_node[4000];

if( group[0].head &gt; group[0].tail )
startPoint = group[0].tail;
</code></pre>

<p>  else</p>

<pre><code>startPoint = group[0].head;

qsort(group,count,sizeof(group[1]),comp_func);

for(i=0;i&lt;4000;i++){
    adj[i]=boundary[i]=-1;
    degree[i]=count_node[i]=0;
}
j=cnt=0;
/*build adjacency*/
for(i=0;i&lt;count;i++){
    while((group[i].head==group[j].head)&amp;&amp;(j&lt;count)){
        cnt++;
        j++;
    }
    adj[group[i].head] = i;
    degree[group[i].head] = cnt;
    boundary[group[i].head]= adj[group[i].head] + degree[group[i].head];
    cnt = 0;
    i = j-1;
}
/*find how mand nodes*/
totalnode = 0;
for(i=0;i&lt;100;i++){
    vertex[i].degree = 0;
    vertex[i].adj = -1;
    vertex[i].bound = -1;
    vertex[i].color = 0;
}
for(i=0;i&lt;count;i++){
    count_node[group[i].head] = 1;
    count_node[group[i].tail] = 1;
    vertex[group[i].head].degree++;
    vertex[group[i].tail].degree++;
    vertex[group[i].head].adj=adj[group[i].head];
    vertex[group[i].tail].adj=adj[group[i].tail];
    vertex[group[i].head].bound=boundary[group[i].head];
    vertex[group[i].tail].bound=boundary[group[i].tail];
}
for(i=0;i&lt;100;i++){
    if(count_node[i]==1){
        totalnode++;
        vertex[i].degree/=2;
    }
}
visited = 0;
for(i=0;i&lt;100;i++)
    used[i]=0;

DFS(1);

step2 = 0;
if(visited!=totalnode)
    printf( "Round trip does not exist.\n" );
else{
    for(i=0;i&lt;100;i++){
        if(count_node[i]==1){
            if((vertex[i].degree%2)!=0){
                printf( "Round trip does not exist.\n" );
                step2 = 1;
                break;
            }
        }
    }
    if(step2==0){
        stack = 0;
        for(j=0;j&lt;4000;j++)
            edge[j]=0;
        find_circuit(startPoint);
        for(j=stack-1;j&gt;0;j--)
            printf("%d ",S[j]);
        printf("%d\n",S[0]);
    }
}
printf("\n");
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>int node1,node2,strt;
int flag = 0;
freopen("302.in","r",stdin);
count = 0;
totalnode = 0;
while(scanf("%d%d",&amp;node1,&amp;node2)==2){
    if(node1==0){
        if(flag==1)
            break;
        else{
            flag = 1;
            build_adj();
            count = totalnode = 0;
            continue;
        }
    }
    scanf("%d",&amp;strt);
    group[count].head = node1;
    group[count].tail = node2;
    group[count++].street = strt;
    group[count].head = node2;
    group[count].tail = node1;
    group[count++].street = strt;
    flag = 0;
}
return 0;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ACM: 294 - Divisors]]></title>
    <link href="http://xwaynec.github.io/blog/2013/11/23/acm-294-divisors/"/>
    <updated>2013-11-23T18:02:17+08:00</updated>
    <id>http://xwaynec.github.io/blog/2013/11/23/acm-294-divisors</id>
    <content type="html"><![CDATA[<p>``` c</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;stdlib.h></h1>

<h1>include&lt;math.h></h1>

<h1>include &lt;memory.h></h1>

<p>/<em>Divisors </em>/
int main()
{</p>

<pre><code>int sample,lower,upper;
int i,j,k,s;
int m,max,maxnum,divisor,prime;
char is_prime[31623];
memset(is_prime,1,31623);
for(i=2;i&lt;31623;i++){
    if(is_prime[i]==1){
        for(k=i*2;k&lt;31623;k=k+i){
            is_prime[k]=0;
        }
    }
}
freopen("294.in","r",stdin);
scanf("%d",&amp;sample);
for(i=0;i&lt;sample;i++){
    scanf("%d%d",&amp;lower,&amp;upper);
    printf("Between %d and %d, ",lower,upper);
    m = (int)(sqrt(upper)+0.001);
    max = 1;
    maxnum = lower;
    for(s=lower;s&lt;=upper;s++){
        int tmp = s;
        divisor = 1;
        for(j=2;j&lt;=m&amp;&amp;tmp&gt;1;j++){
            if((is_prime[j]==1)&amp;&amp;(tmp%j==0)){
                prime = 0;
                while(tmp%j==0){
                    prime++;
                    tmp = tmp / j;
                }
                divisor = divisor * (prime + 1);
            }
        }
        if(tmp &gt; 1)
            divisor = divisor *2;
        if(divisor &gt; max){
            max = divisor;
            maxnum = s;
        }
    }
    printf("%d has a maximum of %d divisors.\n",maxnum,max);
}
return 0;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ACM: 242 - stamp and envelope]]></title>
    <link href="http://xwaynec.github.io/blog/2013/11/22/acm-242-stamp-and-envelope/"/>
    <updated>2013-11-22T14:03:46+08:00</updated>
    <id>http://xwaynec.github.io/blog/2013/11/22/acm-242-stamp-and-envelope</id>
    <content type="html"><![CDATA[<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<h1>define INFINITE 2000</h1>

<p>/<em>Stamps and Envelope Size </em>/
/<em> global variable </em>/
int s;
int n;
int set[10][15];
int N[10];
int f[1010];</p>

<p>int main()
{
  int i, j;
  int k;
  int temp;</p>

<p>  /<em> freopen(&ldquo;242.in&rdquo;, &ldquo;r&rdquo;, stdin); </em>/</p>

<p>  scanf(&ldquo;%d&rdquo;, &amp;s);
  while(s!=0){
  /<em> read input </em>/
  scanf(&ldquo;%d&rdquo;, &amp;n);
  for(i=0; i&lt; n; i++){</p>

<pre><code>scanf("%d", &amp;set[i][0]);
for(j=1; j&lt;= set[i][0]; j++)
scanf("%d", &amp;set[i][j]);
</code></pre>

<p>  }
  /<em> DP for n sets of stamp </em>/
  for(i=0; i&lt; n; i++){</p>

<pre><code>f[0]=0;
/* find max coverage */
for(j=1; ; j++){
f[j]=INFINITE;
/* dynamic programing */
for(k=set[i][0]; k &gt;0; k--){
  temp=j-set[i][k];
  if(temp &gt;=0){
  temp=f[temp]+1;
  if(temp&lt; f[j])
    f[j]=temp;
  }
}
/* check terminate or not */
if(f[j] &gt;s)
  break;
}
N[i]=j-1;
</code></pre>

<p>  }
  /<em> print out </em>/
  for(i=1, temp=0; i&lt; n; i++){</p>

<pre><code>if(N[i] &gt;N[temp])
temp=i;
else if(N[i]==N[temp]){
if(set[i][0]&lt; set[temp][0])
  temp=i;
else if(set[i][0]==set[temp][0] &amp;&amp; set[i][set[i][0]]&lt; set[temp][set[temp][0]])
  temp=i;
}
</code></pre>

<p>  }
  printf(&ldquo;max coverage = %3d :&rdquo;, N[temp]);
  for(i=1; i&lt;= set[temp][0]; i++)</p>

<pre><code>printf("%3d", set[temp][i]);
</code></pre>

<p>  printf(&ldquo;\n&rdquo;);</p>

<p>  scanf(&ldquo;%d&rdquo;, &amp;s);
  }
  return 0;
}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ACM: 166 â€“ Making Change]]></title>
    <link href="http://xwaynec.github.io/blog/2013/11/17/acm-166-making-change/"/>
    <updated>2013-11-17T00:53:00+08:00</updated>
    <id>http://xwaynec.github.io/blog/2013/11/17/acm-166-making-change</id>
    <content type="html"><![CDATA[<p>``` c</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;string.h></h1>

<h1>define UBOUND 1000000</h1>

<p>/<em>Making Change  </em>/
int main(){
  int unlimited[105];
  int coins[6]={1,2,4,10,20,40};
  int i,j;
  int limited[6][145];
  int used[145];
  int p1,p2,price;
  unlimited[0]=0;
  for(i=1;i&lt;=100;i++)</p>

<pre><code>unlimited[i]=UBOUND;
</code></pre>

<p>  for(i=1;i&lt;=100;i++)</p>

<pre><code>for(j=0;j&lt;6;j++){
  if(coins[j]&gt;i) continue;
  if(unlimited[i-coins[j]]+1&lt;unlimited[i])
    unlimited[i]=unlimited[i-coins[j]]+1;
}
</code></pre>

<p>  for(;;){</p>

<pre><code>int total=0,min,minj,max;
for(i=0;i&lt;=140;i++) used[i]=0;
for(i=0;i&lt;6;i++) scanf("%d",&amp;limited[i][0]),total+=limited[i][0]*coins[i];
if(total==0) break;
scanf("%d%*c%d",&amp;p1,&amp;p2);
price=p1*20+p2/5;
max=total&gt;price+40?price+40:total;
for(i=1;i&lt;=max;i++){
  min=UBOUND;
  for(j=0;j&lt;6;j++){
    if(coins[j]&gt;i||limited[j][i-coins[j]]==0) continue;
    if(used[i-coins[j]]+1&lt;min) min=used[i-coins[j]]+1,minj=j;
  }
  used[i]=min;
  if(min&lt;UBOUND){
    for(j=0;j&lt;6;j++)
      limited[j][i]=limited[j][i-coins[minj]];
    limited[minj][i]--;
  }
}
min=UBOUND;
for(i=price;i&lt;=max;i++)
  if(used[i]+unlimited[i-price]&lt;min)
    min=used[i]+unlimited[i-price];
printf("%3d\n",min);
</code></pre>

<p>  }
  return 0;
}
```</p>
]]></content>
  </entry>
  
</feed>
